Сначала нужно скачать сам Python(установится интерпретатор+ документация+IDLE питон). Затем установить IDLE(Pycharm). ВУАЛЯ!!!

Для работы по созданию нескольких сайтов возможно понадобятся разные версии одних и
тех же пакетов, поэтому лучше использовать виртуальное окружение(в pycharm оно создаётся автоматически).
Устанавливает виртуальное окружение модуль venv.
В виртуальном окружении локальные пакеты отличаются от установленных глобальных.

Для наччала проекта: 1. в cmd: $Django-admin stratproject mysite
                                            инструкция название проекта
Создастся папка(mysite), в которой есть папка, называемая пакетом конфигураций. В ней находятся модули проекта, задающие конфигурацию проекта
Также в mysite есть manage.py- специальный файл-утилита, который мы будем использовать для создания различных действий с проектом. Он вызывает утилиту Django-admin 
и передаёт введённую нами команду(своеобразный посредник)
Также в mysite есть db.sqlite3- БД, с которой Django работает по умолчанию. Мы вольны подключать любую БД
wsgi.py и asgi.py- модули, связывающие проект с веб-сервером
settings.py- модуль с настройками проекта, который содержит подключения к БД, пути к папкам приложений, файлов, параметров и др. всевозможные настройки.
urls.py- модуль с маршрутами проекта(для маршрутизатора)

Далее попробуем запустить сервер:
-переходим в папку, где находится manage.py
-$python manage.py runserver 
команда runserver запускает тот самый сервер, который поставляется Django. Запускается по адресу(написано в cmd)-"Starting development server at http://127.0.0.1:8000/"
Этот сервер отслеживает изменения в вашем проекте:сервер с большой долей вероятности подхватывает изменения и автоматически презапускается. Но порой лучше на это не надеяться
( Django практически не отслеживает измененния в новых файлов)
-сервер отображает в cmd HTTP-запросы
-для отключения сервера: ctrl+C
-Для запуска сервера с другого порта: python manage.py runserver 4000
-Для запуска сервера с другим адресом: python manage.py runserver 1.2.3.4:4000


Сайт, который мы создаём, состоит из приложений(папка(пакеты) пайтона с содержимым(с модулями)). Философия Джанго:
-желательно,чтобы создаваемые приложения были намного менее связанные друг с другом.
-приложения Django- это часть нашего сайта
-приложения- это функционал, в котором реализован тот или ино раздел нашего сайта.
-в идеале если нам на 2 разных сайтах нужен 1 и тот же блок, мы должны иметь возможность использовать одно и то же приложение(с точечными изменениями)

Создание приложения:
-$ python manage.py startapp(инструкция) news(название приложения)
В папке приложения будут находиться:
-migrations- миграции приложения
-init.py- пакет пайтона.
-admin.py- файл модуля настройки админки. Django предлагает уже готовую админку, в которой все наши зарегестрированные приложения будут отображаться. Мы можем эти приложения 
поднастроить, если нужно, но по умолчанию ничего делать нет необходимости.
-apps.py- модуль настроек нашего приложения.
-models.py- файл, в кот. хранятся модели нашего приложения.
-tests.py- модуль с тестирующими процедурами.
-views.py- файл, в котором будут храниться контроллеры нашего приложения

Регистрация приложения:
-конфигурации сайта(mysite)-->settings.py--> ищем список: INSTALLED_APPS. 
-2 варианта записи в список:
	1. просто название приложения- news(но, когда будем писать админку, нужно будет прописывать больше кода).---> 
--->  2. пишем полный путь через методы: news.appsNewsConfig(этот класс файла apps.py, кот. находится в news(в приложении)		


MVC в Django:
MVC- архитектурный паттерн
В Django MVC называется MTV
MVC=MTV:
Model=Model
View=Template
Controller=View
-современные приложения создаются так, чтобы ограничивать логику и представление.
-раньше писали всё в одном файле, но поняли что так делать не стоит--> на смену эту подходу пришёл MVC, когда приложение разбивают на части. И таковые часто скрыты 
за аббревиатурой MVC
Model отвечает за работу с данными:хранение данных, получение данных откуда то из хранилищ(как правило это БД)
View отвечает за представление этих данных(красивое отображение данных). По сути это шаблон(HTML-страничка, кот. будет покзана пользователю.
Controller-связующее звено, кот. принимает запросы от пользователей, понимает какую модель он должен вызвать, чтобы получить какие-то конкретные данные-->подклю-
чает нужный вид и передаёт в него эти данные для отображения.
Аналогия: Покупатель(пользователь) пришёл в магазин и ему нужен чай. Продавец(Controller) сопроводил покупателя в нужный отдел(Model) и упаковал нужный чай(view) 
и мы получиили свой чай
-Model- models.py
-Template- сами создаём этот файл
-View- views.py

Контроллеры и маршруты:
-Контроллер вызывается в ответ на клиентский запрос, обрабатывает его и возвращает ответ в виде представления.
-Контроллеры Django могут выступать в 2 вариантах:
	1. Контроллер функций
	2. Контроллер классов
	-либо их комбинация
-все функции принимают обязательный аргумент request(в нём хранятся все необходимые данные о полученном запросе, о клиенте)	
//////
from django.shortcuts import render
from django.http import HttpResponse

def index(request):
    print(request)
    return HttpResponse('Hello world!')
/////---> чтобы понять, что пользователь обращается именно к этому приложению, нужно сконфигурировать тот самый маршрутизатор, который принимиает первичный запрос клиента
и сравнивает его со списком своих маршрутов, адресов и говорит, есть ли у него ткой адрес( если есть, то вызывает этот самый адрес( говорит клиенту, куда ему нужно отправиться)
-список адресов находится в пакете конфигураций(urls.py)--->пока что мы можеи ввести в url странчки только /admin  и выскочит существующая админка(потому что её путь прописан 
в urls.py)---> мы должны сообщаить маршрутизатору, что при обращении по соответствующему адресу нужно вызывать соответствующий контроллер---> нужно импортировать этот
контроллер. Чтобы редактор не ругался на путь, который мы укажем, нужно сделать mysite корневой директорией--> ПКМ по mysite---> Make directory as---> Sources root
---> прописываем path (пишем, что при обращении к строке адреса news/(не указывем полностью адрес, потому что по умолчанию там уже подразумевается имя домена 
и оно отбрасывается) и вторым аргументом указываем функцию, кот. хотим вызвать:  
/////
from django.contrib import admin
from django.urls import path
from news.views import index
urlpatterns = [
    path('admin/', admin.site.urls),
    path('news/', index),
]
/////

- path(route(по сути просто нвзвание-маршрут), view(функция) )
С другой стороны со времннем приложение может разрастаться и соответственно количество адресов может расти---> помещать все адреса в список urlpatterns 
не самая хорошая практика+ нарушается принцип, согласно которому приложения создаются как можно менее связанными(список адресов будет храниться
вне приложения(в пакете конфигурации), то при копировании приложения в другой проект придётся каким-то образом переносить маршруты--->чтобы этого не было, мы можем хранить 
маршруты в самом приложении---> достигается это путём импорта этих самых маршрутов--->из модуля django.urls импортируем ф-ию include--->2-ым пар-ом для news 
будем передавать список вложенных маршрутов(в качестве аргумента указываем файл news.urls со списком маршрутов(без расширения .py)(этот файл нужно создать)---> там точно 
также прописываем список---> далее при обращении обращении по адресу 'news/'---> django видит, что нужно подключить другой список маршрутов(news.urls) и отбрасывает адрес
'news/'---> 1-ый аргумент в path в списке из news.urls пустой, потому что адрес, по которому вызывается ф-ия index будет 'news/'.
//// mysite/urls.py
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('news/', include('news.urls')),
]
////
//// news/urls.py
from django.urls import path
from .views import *

urlpatterns = [
    path('', index),
    path('test/', test),  //// адрес уже будет 'news/test/'
]
////


МОДЕЛИ:
- Модели хранят данные в БД
- В Django модель- это представление таблицы в БД и её полей средствами python
- Модель в Django описывется классом(внутри models.py в приложении. Этот класс явл. подклассом импортируемого в этот файл модуля(from django.db import models). В этом классе
мы будем описывать атрибуты(свойства) класса- это явл. обязательным в моделе класса. Атрибуты модели- это соответствующие поля в таблицах БД.
- Поля: отвечают за 3 вещи:
     1. Сообщает какой тип данных нужно хранить поле
     2. Создание соответствующего типа поля в форме(в html-коде)
     3. Правила валидации: при заполнении формы( нельзя будет в численном типе данных написат строку к примеру)
- Если мы не создаём поле integers с первичным ключом (с атрибутом primary key), Django автоматически создаст id,кот. будет первичным ключом

Миграции:
- это модуль python, который Django создаёт на уровне модели. Миграции необходимы для создания в БД таблиц, полей, индексов, связей и т.д.
- при изменении данных в модели будут создаваться новые файлы в папке миграции, которые будут описывать эти изменения
- по сути миграции- ни что иное, как аналог системы контроля версий для наших моделей
- крайняя рекомендация: сразу продумывать структуру модели, чтобы потом если и делать изменения, то минимальные
Создание файлов миграции: в cmd---> $pip install Pillow(если не установлено)---> python manage.py makemigrations
- чтобы посмотреть, какие sql-запросы были сделаны в процессе создания миграции: $python manage.py sqlmigrate news 0001(номер файла)
Далее нужно выполнить миграции: $ python manage.py migrate
Чтобы указать Django, куда сохранять загруженные файлы, нужно определить MEDIA_ROOT в качестве полного пути к каталогу(для производительности эти файлы не хранятся в бд):
 	- mysite---> setting.py--->:
		////
		MEDIA_ROOT = OS.PATH.JOIN(BASE_DIR, 'media')     /// BASE_DIR - корневая пака, 'media' - папка, которая создаётся(туда будет всё загружаться)
+нужно определить MEDIA_URL в качестве базового общедоступного URL-адреса этого каталога:
		////
		MEDIA_URL = '/media/'

Чтобы загруженные файлы можно было просматривать на сайте, необходимо создать соответствующий маршрут, кот. будет указывать на соотв. файлы---> для этого исп.
ф-ия static из модуля django.conf.urls.static. Эта ф-ия создаст маршрут, по которому маршрутизатор передаст при запросе файлов управление
специальному контроллеру django, кот. и отдаст нам файл для просмотра( это необходимо только в отладочном режиме, то есть когда мы разрабатываем сайт и используем
отладочный сервер. Когда мы переведём сайт на веб-сервер, этот маршрут нам будет не нужен и файлы будут обслуживаться самим веб-сервером(веб-сервер будет сам
раздавать эти файлы):
	mysite--->urls.py:
	////
	from django.conf import settings
	
	if settings.DEBUG:      /// если идёт разработка, то:
      	urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT) ///создаём маршрут(по нему Django- контроллер будет отдавать необходимые медиа-файлы)

- константа DEBUG(в mysite--->setting.py)- указывает на то, что ведётся режим разработки( когда будем переносить сайт, эту константу необходимо поставить в False

Основы работы с моделями. CRUD:
- CRUD- Create Read Update Delete
- ORM-объектня модель для работы с БД(даже не понадобится знать язык SQL). Каждая запись- это объект. Когда мы делаем какие-либо манипуляции 
 с данными, мы работаем с объектом. У объектов есть свойства(атрибуты)-поля в таблице
- протестируем API для работы с данными модели(ORM): с помощью консоли Django: $python manage.py shell(открытие консоли Django)---> для работы с моделью нужно 
 её импортировать: 
  $from news.models import News
  $News(title='Новость 1', content='Контент новости 1')		///вызов конструктора
  Но данные ещё не добавились в таблицу, так как мы её не сохранили. Это происходит, потому что модели в Django ленивые- они не выплняют 
  запрос(sql), пока мы не подадим команду
  $news1 = _   /// создаём переменную( _ - псевдопеременная, у которой хранится предыдущий результат)
  $news1   /// выведет  None(None - значение поля id(назначается автоматически при занесении днных в таблицу)
  $news1.title   /// выведет: Новость 1
  $news1.id   /// ничего не выводит
  $news1.save()   ///сохраняем
  $news.id   /// выведет:1
	Мы можем посмотреть выполненные запросы:
  $from django.db import connection
  $connection.queries
 - в Django можно обратиться к полю первичного ключа с помощью свойства pk:
	$news1.pk /// выведет: 1
 - 2-ой вариант добавления записи:
	$news2 = News()
	$news2.title = 'Новость 2'
	$news2.content = 'Новость 2'
	$news2.save()
 - 3-ий вариант записи: с помощью атрибута класса objects(является экземпляром класса Manager):
	$news3 = News.objects.create(title='Новость 3', content='Контент новости 3')   /// ЗАПИСЬ БУДЕТ АВТОМАТИЧЕСКИ СОХРАНЕНА
 - Получение записи из объекта:
	$News.objects.all()
	- чтобы было строчное представление более информативным напишем ф-ию в mysite--->models.py:
		////
		def __str__(self):
     	    		return self.title
		////
	- чтобы изменения сохранились, выйдем из консоли Django($exit())
	-$news= _    ////создадим переменную и поместим эти записи в неё
	-$  for item in news:                       
	 ...     print(item.title, item.is_published) 
 - Получение отфильтрованной записи из объекта:
	-$ News.objects.filter(title='Новость 1')   
 - Получение единственной записи из объекта:
	-$News.objects.get('атрибут')   ///если будет больше 1 записи + если запись не будет найдена---> выдаст ошибку
	 Как правило применяют с первичным ключом(pk)
 - Изменение записи:
	-$News.objects.get(pk=3)  
	-$news3= _ 
	-$news3.title= 'Новости 3'
	-$news3.save()
 - Удаление записи:
      -$news5= News.objects.get(pk=5)
      -$news5.delete()
 - Сортировка записей:
	-$News.objects.order_by('-title') /// отсортирует в оратном порядке(благодаря знаку минус перед title

 - Все записи, кроме:
	-$News.objects.exclude(атрибут)

TEMPLATE:
*Мы можем выводить данные следующим образом: 
////
def index(request):
    news = News.objects.all()
    res = '<h1>Список новостей</h1>'
    for item in news:
        res+=f'<div>\n<p>{item.title}</p>\n<p>{item.content}</p>\n</div>\n<hr>\n'
    return HttpResponse(res)
////
*Но это занимет слишком много времени и места.Поэтому:
- template- шаблон
- рендеринг-процесс, в котором мы берём некий файл и заполняем его данными из модели.
- Django позволяет рендерить шаблоны
- работать с шаблонами нужно с помощью шаблонизатора
- в шаблонизаторе используются директивы, теги и фильтры
- по умолчанию Django ищет шаблоны в папке templates в пакете приложений: создаём папку templates--->в этой папке создаём папку с именем приложения(создаём эту папку с таким названием, чтобы не было конфликта при поиске
  этих шаблонов на этапе компиляции(чтобы было пространство имён) --->создаём шаблон index.html(название даётся по названию экшена- это название функции(действия) в views.py)

- чтобы провести рендеринг шаблона, мы должны подключить спец. функцию: from django.shortcuts import render---> делаем изменения в коде:
////
def index(request):
    news = News.objects.all()
    return render(request, 'news/index.html', {'news': news, 'title': 'Список новостей'})   /// render(1-ый арг.- request, 2-ой арг.- путь до шаблона, 3-ий арг.- словарь(
////
